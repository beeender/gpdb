-- @Description Tests the parallel cursor for select replcated table
--
DROP TABLE IF EXISTS rt1;
DROP
CREATE TABLE rt1 (a INT) DISTRIBUTED REPLICATED;
CREATE
insert into rt1 select generate_series(1,100);
INSERT 100

--------- Test1: Basic test for parallel cursor on replicated table
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM rt1;
DECLARE
2: BEGIN;
BEGIN
2: DECLARE c2 PARALLEL CURSOR FOR SELECT * FROM rt1;
DECLARE
3: BEGIN;
BEGIN
3: DECLARE c3 PARALLEL CURSOR FOR SELECT * FROM rt1;
DECLARE

-- Here because replicated table will execute on seg id: session_id % segment_number
-- Just declare & execute parallel cursors in all segment_number (i.e. 3) sessions,
-- so that there should have specific session: MOD(sessionid,3)=1;
-- Get token only in specific session id and retrieve this token.
4: @out_sh 'get_cell TOKEN1 3 1 && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN1}/${NL}s/${TOKEN1}/token_id1/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS_INFO(TRUE) WHERE MOD(sessionid,3)=1;
 token                  | status
------------------------+--------
 token_id1 | INIT
(1 row)
1&: EXECUTE PARALLEL CURSOR c1;  <waiting ...>
2&: EXECUTE PARALLEL CURSOR c2;  <waiting ...>
3&: EXECUTE PARALLEL CURSOR c3;  <waiting ...>
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN1';
 status 
--------
(0 rows)

 status 
--------
(0 rows)

 status 
--------
 READY  
(1 row)

 status 
--------
(0 rows)
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN1#${TOKEN1}#" ': RETRIEVE 10 FROM "@TOKEN1";
ERROR:  failed to attach non-existing endpoint of token token_id1 (cdbendpoint.c:1690)

ERROR:  failed to attach non-existing endpoint of token token_id1 (cdbendpoint.c:1690)

 a  
----
 1  
 2  
 3  
 4  
 5  
 6  
 7  
 8  
 9  
 10 
(10 rows)

ERROR:  failed to attach non-existing endpoint of token token_id1 (cdbendpoint.c:1690)
-- cancel all 3 sessions
4: select pg_cancel_backend(pid) from pg_stat_activity, gp_endpoints_info(true) where sess_id = sessionid AND (cursorname ='c1' or cursorname='c2' or cursorname='c3');
 pg_cancel_backend 
-------------------
 t                 
 t                 
 t                 
(3 rows)
1<:  <... completed>
ERROR:  canceling statement due to user request
2<:  <... completed>
ERROR:  canceling statement due to user request
3<:  <... completed>
ERROR:  canceling statement due to user request

1: ROLLBACK;
ROLLBACK
2: ROLLBACK;
ROLLBACK
3: ROLLBACK;
ROLLBACK

--------- Test2: Basic test for parallel cursor on replicated table
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM rt1 ORDER BY a;
DECLARE
2: BEGIN;
BEGIN
2: DECLARE c2 PARALLEL CURSOR FOR SELECT * FROM rt1 ORDER BY a;
DECLARE
3: BEGIN;
BEGIN
3: DECLARE c3 PARALLEL CURSOR FOR SELECT * FROM rt1 ORDER BY a;
DECLARE

-- Here because replicated table will execute on seg id: session_id % segment_number
-- Just declare & execute parallel cursors in all segment_number (i.e. 3) sessions,
-- so that there should have specific session: MOD(sessionid,3)=1;
-- Get token only in specific session id and retrieve this token.
4: @out_sh 'get_cell TOKEN2 3 1 && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN2}/${NL}s/${TOKEN2}/token_id2/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS_INFO(TRUE) WHERE MOD(sessionid,3)=1;
 token                  | status
------------------------+--------
 token_id2 | INIT
(1 row)
1&: EXECUTE PARALLEL CURSOR c1;  <waiting ...>
2&: EXECUTE PARALLEL CURSOR c2;  <waiting ...>
3&: EXECUTE PARALLEL CURSOR c3;  <waiting ...>
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN2';
 status 
--------
(0 rows)

 status 
--------
(0 rows)

 status 
--------
 READY  
(1 row)

 status 
--------
(0 rows)
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN2#${TOKEN2}#" ': RETRIEVE 10 FROM "@TOKEN2";
ERROR:  failed to attach non-existing endpoint of token token_id2 (cdbendpoint.c:1690)

ERROR:  failed to attach non-existing endpoint of token token_id2 (cdbendpoint.c:1690)

 a  
----
 1  
 2  
 3  
 4  
 5  
 6  
 7  
 8  
 9  
 10 
(10 rows)

ERROR:  failed to attach non-existing endpoint of token token_id2 (cdbendpoint.c:1690)
-- cancel all 3 sessions
4: select pg_cancel_backend(pid) from pg_stat_activity, gp_endpoints_info(true) where sess_id = sessionid AND (cursorname ='c1' or cursorname='c2' or cursorname='c3');
 pg_cancel_backend 
-------------------
 t                 
 t                 
 t                 
(3 rows)
1<:  <... completed>
ERROR:  canceling statement due to user request
2<:  <... completed>
ERROR:  canceling statement due to user request
3<:  <... completed>
ERROR:  canceling statement due to user request

1: ROLLBACK;
ROLLBACK
2: ROLLBACK;
ROLLBACK
3: ROLLBACK;
ROLLBACK

--------- Test3: Basic test for parallel cursor on replicated table
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM rt1 WHERE MOD(a,3)=1;
DECLARE
2: BEGIN;
BEGIN
2: DECLARE c2 PARALLEL CURSOR FOR SELECT * FROM rt1 WHERE MOD(a,3)=1;
DECLARE
3: BEGIN;
BEGIN
3: DECLARE c3 PARALLEL CURSOR FOR SELECT * FROM rt1 WHERE MOD(a,3)=1;
DECLARE

-- Here because replicated table will execute on seg id: session_id % segment_number
-- Just declare & execute parallel cursors in all segment_number (i.e. 3) sessions,
-- so that there should have specific session: MOD(sessionid,3)=1;
-- Get token only in specific session id and retrieve this token.
4: @out_sh 'get_cell TOKEN3 3 1 && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN3}/${NL}s/${TOKEN3}/token_id3/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS_INFO(TRUE) WHERE MOD(sessionid,3)=1;
 token                  | status
------------------------+--------
 token_id3 | INIT
(1 row)
1&: EXECUTE PARALLEL CURSOR c1;  <waiting ...>
2&: EXECUTE PARALLEL CURSOR c2;  <waiting ...>
3&: EXECUTE PARALLEL CURSOR c3;  <waiting ...>
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN3';
 status 
--------
(0 rows)

 status 
--------
(0 rows)

 status 
--------
 READY  
(1 row)

 status 
--------
(0 rows)
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN3#${TOKEN3}#" ': RETRIEVE 10 FROM "@TOKEN3";
ERROR:  failed to attach non-existing endpoint of token token_id3 (cdbendpoint.c:1690)

ERROR:  failed to attach non-existing endpoint of token token_id3 (cdbendpoint.c:1690)

 a  
----
 1  
 4  
 7  
 10 
 13 
 16 
 19 
 22 
 25 
 28 
(10 rows)

ERROR:  failed to attach non-existing endpoint of token token_id3 (cdbendpoint.c:1690)
-- cancel all 3 sessions
4: select pg_cancel_backend(pid) from pg_stat_activity, gp_endpoints_info(true) where sess_id = sessionid AND (cursorname ='c1' or cursorname='c2' or cursorname='c3');
 pg_cancel_backend 
-------------------
 t                 
 t                 
 t                 
(3 rows)
1<:  <... completed>
ERROR:  canceling statement due to user request
2<:  <... completed>
ERROR:  canceling statement due to user request
3<:  <... completed>
ERROR:  canceling statement due to user request

1: ROLLBACK;
ROLLBACK
2: ROLLBACK;
ROLLBACK
3: ROLLBACK;
ROLLBACK

--------- Test4: Basic test for parallel cursor on replicated table
1: BEGIN;
BEGIN
1: DECLARE c1 PARALLEL CURSOR FOR SELECT * FROM rt1 WHERE MOD(a,3)=1 OR MOD(a,3)=2;
DECLARE
2: BEGIN;
BEGIN
2: DECLARE c2 PARALLEL CURSOR FOR SELECT * FROM rt1 WHERE MOD(a,3)=1 OR MOD(a,3)=2;
DECLARE
3: BEGIN;
BEGIN
3: DECLARE c3 PARALLEL CURSOR FOR SELECT * FROM rt1 WHERE MOD(a,3)=1 OR MOD(a,3)=2;
DECLARE

-- Here because replicated table will execute on seg id: session_id % segment_number
-- Just declare & execute parallel cursors in all segment_number (i.e. 3) sessions,
-- so that there should have specific session: MOD(sessionid,3)=1;
-- Get token only in specific session id and retrieve this token.
4: @out_sh 'get_cell TOKEN4 3 1 && export MATCHSUBS="${MATCHSUBS}${NL}m/${TOKEN4}/${NL}s/${TOKEN4}/token_id4/${NL}" && echo "${RAW_STR}" ': SELECT token,status FROM GP_ENDPOINTS_INFO(TRUE) WHERE MOD(sessionid,3)=1;
 token                  | status
------------------------+--------
 token_id4 | INIT
(1 row)
1&: EXECUTE PARALLEL CURSOR c1;  <waiting ...>
2&: EXECUTE PARALLEL CURSOR c2;  <waiting ...>
3&: EXECUTE PARALLEL CURSOR c3;  <waiting ...>
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN4#${TOKEN4}#" ': SELECT status FROM GP_ENDPOINTS_STATUS_INFO() WHERE token='@TOKEN4';
 status 
--------
(0 rows)

 status 
--------
(0 rows)

 status 
--------
 READY  
(1 row)

 status 
--------
(0 rows)
*R: @in_sh ' echo "${RAW_STR}" | sed "s#@TOKEN4#${TOKEN4}#" ': RETRIEVE 10 FROM "@TOKEN4";
ERROR:  failed to attach non-existing endpoint of token token_id4 (cdbendpoint.c:1690)

ERROR:  failed to attach non-existing endpoint of token token_id4 (cdbendpoint.c:1690)

 a  
----
 1  
 2  
 4  
 5  
 7  
 8  
 10 
 11 
 13 
 14 
(10 rows)

ERROR:  failed to attach non-existing endpoint of token token_id4 (cdbendpoint.c:1690)
-- cancel all 3 sessions
4: select pg_cancel_backend(pid) from pg_stat_activity, gp_endpoints_info(true) where sess_id = sessionid AND (cursorname ='c1' or cursorname='c2' or cursorname='c3');
 pg_cancel_backend 
-------------------
 t                 
 t                 
 t                 
(3 rows)
1<:  <... completed>
ERROR:  canceling statement due to user request
2<:  <... completed>
ERROR:  canceling statement due to user request
3<:  <... completed>
ERROR:  canceling statement due to user request

1: ROLLBACK;
ROLLBACK
2: ROLLBACK;
ROLLBACK
3: ROLLBACK;
ROLLBACK